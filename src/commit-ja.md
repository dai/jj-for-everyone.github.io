# 新しいコミットの作成

````admonish reset title="Reset your progress" collapsible=true
To reset your progress to the start of this chapter, run the following command:

```sh
curl https://jj-for-everyone.github.io/reset.sh | bash -s commit
cd ~/jj-tutorial/repo
```
````

変更のセットが完了したら、新しいコミットを作成する必要があります。
そうしないと、次の変更は同じコミットに記録されます。
それにより、後でプロジェクトの進化を理解するのが難しくなります。

新しいコミットを作成する前に、作業してきたコミットに説明を付ける必要があります。
すべてのコミットには説明が必要です、短いものでも。

概念的には、今2つのことを行う必要があります：
1. 完了した変更、つまりワーキングコピー（`@`）コミットに記録された変更に説明を付ける。
1. 完全に新しいコミットを開始し、それは完了したコミットの子です。

```admonish title="Gitを知っている場合の混乱の源" collapsible=true
このチュートリアルはGitの経験がないことを前提としています。
しかし、Gitを_使用した_ことがある場合、このチュートリアルを理解するのが実際にはより難しくなるかもしれません。
理由は、GitとJujutsuの両方に `commit` というサブコマンドがあるが、動作が異なるからです。

Gitでは、変更はコミットに自動的に記録されません。
代わりに、コミット外に存在し、手動でコミットに追加されるまでです。
`git commit` は新しい変更と新しいコミットメッセージを含むコミットを作成します。

Jujutsuでは、常にコミットが既に存在し、変更は自動的に記録されます。
したがって、`jj commit` 中にタイプする説明は、既に長い間存在していたコミットに適用されます。
_新しい_コミットは完全に空で、説明がありません。
それは今後の変更の自動記録の準備ができています。
```

これらのタスクを一度に行うコマンドは：

```sh
jj commit
```

これにより、コミットの説明を書くためのテキストエディタが開きます。
[インストールとセットアップ](./install.md#installing-a-simple-text-editor)で指示に従った場合、エディタは `edit` になります。
説明を書いたら、メニューバーの "File" をクリックし、"Exit" をクリックするか、<kbd>Ctrl+Q</kbd> を押してテキストエディタを終了します。
ファイルを保存するかどうかを確認し、<kbd>Enter</kbd> を押して確認します。

テキストファイルが空で始まらないことに気づくかもしれません。
既にいくつかの行が含まれています：

```
JJ: This commit contains the following changes:
JJ:     A README.md
JJ:
JJ: Lines starting with "JJ:" (like this one) will be removed.
```

`JJ:` で始まる行は_コメント_で、`#` で始まる行と同様です。
最終的なコミット説明の一部にはなりませんので、削除する必要はありません。
Jujutsuはこれらのコメントを使用して、このコミットで変更したファイルを思い出させます。
それは良いコミット説明のためのインスピレーションとして役立ちます。

テキストエディタにタイプできる例の説明はこちら（またはコピーして貼り付け）：

```
Add readme with project title

It's common practice for software projects to include a file called
README.md in the root directory of their source code repository. As the
file extension indicates, the content is usually written in markdown,
where the title of the document is written on the first line with a
prefixed `#` symbol.
```


ここには少し構造があります、従うべきです。
説明の最初の行は**件名**と呼ばれます。
時々、件名だけが必要ですが、変更をより詳細に説明するために、それを**本文**でフォローできます。
件名と本文は**空行で区切られます**。
両方とも**72文字**を超えてはいけません。

コミットメッセージは重要です、なぜならそれらが後で変更とその動機を理解するのを助けるからです。
この重要性はスペクトルにあります：
プロジェクトに多くの人が関与し、長寿であるほど、良いコミットメッセージが重要になります。
例えば、Linuxカーネルは多十年プロジェクトで、数千人が一緒に働いています。
Linux開発者は良いコミットメッセージに多くの考えと努力を注ぎます。
スペクトルの反対側には、単一の講義の宿題を保存するための学生のリポジトリがあるかもしれません。
プロジェクトは数ヶ月で終わり、学生が履歴を掘り起こす可能性は低いです。
その学生は良いコミットメッセージにあまり時間を投資しないでしょう。

```admonish info title="良いコミットメッセージの追加のヒント" collapsible=true
任意のタイプのプロジェクトのための追加の慣習は良い実践です。

**件名行を50文字未満に保つ**\
72文字はハードリミットですが、件名行は可能な限り簡潔にするのが通常有益です。
それは多くの場所で表示され、人々があなたの変更の一般的なアイデアを得るためにあまり読まないようにします。
50文字を超えて定期的に行く場合、単一のコミットに無関係な変更を組み合わせているかもしれません。
無関係な変更を別々のコミットに分離すると、簡潔な件名行を作成するのが簡単になります。
しかし、必要に応じて50文字を超える状況は常にありますので、心配しないでください。

**件名行で命令形を使用する**\
コミットメッセージを書くときの一般的な本能は、**過去形**で何をしたかを説明することです、例えば "Fixed bugs and improved code"。
または、コミットの**内容**を説明すること、例えば "bug fixes and code improvements"。
代わりに、**コマンドや指示**を与えるように件名を書いてください、例えば "Fix bugs and improve code"。
結果の履歴はより自然に読めます。
これは主に件名に適用され、本文のスタイルはより柔軟です。

**読者の靴を履く**\
コミットメッセージの対象読者は、プロジェクト履歴の将来の読者です。
彼らは**何**が変更されたか、**なぜ**かを理解しようとしています。
彼らはコンテンツ変更を直接読むことで**どのように**それをしたかを常に知ることができますので、理想的なコミットメッセージはそれを補完するものです。
コンテンツ自体に存在しない情報や、変更をより迅速に理解するためのガイダンスが良い候補です。
```

`jj commit` を実行した結果を `jj log` で見てみましょう：

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>  <span class="bold "></span><span class="bold highlighted purple ">p</span><span class="highlighted dimgray ">wpuwyto</span><span class="bold "> </span><span class="bold yellow ">alice@local</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-22 20:22:36</span><span class="bold "> </span><span class="bold highlighted blue ">3</span><span class="highlighted dimgray ">5de496a</span><span class="bold "></span>
│  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
○  <span class="bold "></span><span class="bold purple ">m</span><span class="highlighted dimgray ">kmqlnox</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-22 20:20:34</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">5</span><span class="highlighted dimgray ">b79353a</span>
│  Add readme with project title
<span class="bold "></span><span class="bold highlighted cyan ">◆</span>  <span class="bold "></span><span class="bold purple ">z</span><span class="highlighted dimgray ">zzzzzzz</span> <span class="green ">root()</span> <span class="bold "></span><span class="bold blue ">0</span><span class="highlighted dimgray ">0000000</span>
</pre>

ここで観察できるいくつかのことがあります：
- 新しいコミットは以前のワーキングコピーコミットの子です。
- 以前のコミットは与えた説明の件名行を表示します。
- 新しいコミットはワーキングコピーになり、さらなるファイル変更は新しいコミットに記録されます。
- 以前のコミットは `git_head()` でマークされています。
  このマーカーは重要ではありません、無視できます。
- 以前のコミットはルートコミットとは異なる記号（円）を持ちます。
  これは将来学ぶ重要な機能に関連しています。

バージョン管理されたプロジェクトで作業するときに最も行うワークフローを管理するツールを手に入れました：
1. 変更を行う
1. 新しいコミットを作成する

これらの2つのステップを繰り返すのが最も行うことです。
