# マージコミットの作成

````admonish reset title="Reset your progress" collapsible=true
To reset your progress to the start of this chapter, run the following command:

```sh
curl https://jj-for-everyone.github.io/reset.sh | bash -s merge
cd ~/jj-tutorial/repo
```
````

あなたを長く引きつけておきましたが、ようやく両方の変更を含むバージョンを組み合わせましょう。

それを達成する方法は実際には2つありますが、今は一つを見ます。
マージコミットを作成します。
名前が示すように、マージコミットは2つ（またはそれ以上！）のコミットからの変更をマージします。

これまで `jj commit` コマンドで新しいコミットを作成してきました。
それは2つのことを一度に行います：完了したコミットに説明を付け、新しいコミットを開始します。
残念ながら、マージコミットを作成できません。

より "low-level" な新しいコミット作成コマンドがあります、`jj new` と呼ばれます。
それはコミットを作成するだけで、説明を変更しません。
重要なのは、追加の引数として**親**のリストを取ることです。
これにより、2つの親を持つコミット、つまりマージコミットを作成できます：

```sh
jj new main @-
```

`jj log` で結果を見てみましょう：

<!-- generated by aha script -->
<pre class="aha">
<span class="bold "></span><span class="bold green ">@</span>    <span class="bold "></span><span class="bold highlighted purple ">t</span><span class="bold highlighted dimgray ">wywpklt</span><span class="bold "> </span><span class="bold yellow ">alice@local</span><span class="bold "> </span><span class="bold highlighted cyan ">2025-07-22 21:26:35</span><span class="bold "> </span><span class="bold highlighted blue ">7</span><span class="bold highlighted dimgray ">64f3651</span><span class="bold "></span>
├─╮  <span class="bold "></span><span class="bold highlighted green ">(empty)</span><span class="bold "> </span><span class="bold highlighted green ">(no description set)</span><span class="bold "></span>
│ ○  <span class="bold "></span><span class="bold purple ">z</span><span class="highlighted dimgray ">zywylnt</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-22 21:17:31</span> <span class="purple ">main?? main@git</span> <span class="green ">git_head()</span> <span class="bold "></span><span class="bold blue ">f8</span><span class="highlighted dimgray ">e44920</span>
│ │  Add Python script for greeting the world
<span class="bold "></span><span class="bold highlighted cyan ">◆</span> │  <span class="bold "></span><span class="bold purple ">q</span><span class="highlighted dimgray ">uvtvrzl</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-22 21:27:24</span> <span class="purple ">main?? main@origin</span> <span class="bold "></span><span class="bold blue ">6</span><span class="highlighted dimgray ">06959ce</span>
├─╯  Document hello.py in README.md
<span class="bold "></span><span class="bold highlighted cyan ">◆</span>  <span class="bold "></span><span class="bold purple ">k</span><span class="highlighted dimgray ">rymmwqm</span> <span class="yellow ">alice@local</span> <span class="cyan ">2025-07-22 21:21:53</span> <span class="bold "></span><span class="bold blue ">1</span><span class="highlighted dimgray ">581674f</span>
│  <span class="green ">(empty)</span> Merge code and documentation for hello-world
~
</pre>

興味深い！
新しいマージコミットの2つの親がコミットグラフで簡単に確認できます。
この新しいコミットがAliceとBobの両方の変更を含むことを確認できます：

```sh
cat README.md
cat hello.py
```

Jujutsuは変更を組み合わせるのが賢いです、しかし賢すぎません。
プロジェクトの同じ部分を変更する変更を組み合わせると、**conflict** が発生します。
競合は必ずしも悪いものではなく、個々の変更が何を達成しようとしていたかを尊重しながら、手動で変更を組み合わせる必要があることを示す信号です。
競合を解決する方法は次のレベルでトピックです。

これをマージコミットでラップアップし、リモートにプッシュしましょう：

```sh
jj commit -m "Merge code and documentation for hello-world"
jj bookmark move main --to @-
jj git push
```

ふう！
それは激しかった。
今 `jj log` を実行すると、デフォルトで複雑な分岐とマージが隠されます。
`jj log --revisions 'all()'` でそれを明らかにできます。
