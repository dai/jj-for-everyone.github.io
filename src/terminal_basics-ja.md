# ターミナル基礎

この章はJujutsuやバージョンコントロールについてではありません。
しかし、このチュートリアルではターミナルで作業する必要がありますので、基礎をカバーしましょう。
ターミナルに既に快適な場合は、この章を自信を持ってスキップできます。

## ターミナルとは何ですか？

ターミナルはオペレーティングシステムにテキストとしてコマンドを入力することを可能にするアプリケーションです。
コマンドは通常テキストを生成し、それがあなたに表示されます。

ターミナルはコンピュータと対話する主要な方法でした。
それはグラフィカルユーザーインターフェースの時代より前です。
今日、ターミナルは同じように動作しますが、通常のアプリウィンドウの中にあります。
アプリは異なる名前を持つことができますが、"Terminal" と "Console" またはその変種が最も一般的です。

## プロンプト

ターミナルを開始すると、**プロンプト**と呼ばれる初期テキストが表示されます。
コマンドが終了するたびに、プロンプトが再表示されます。
それはあなたが次のコマンドを入力できる合図です。
プロンプトの例は次のようになります：

```
[username@hostname ~]$
```

これは後で役立つ情報を示しますが、今はそれを無視してください。
プロンプトは通常ドル **`$` ** またはパーセント **`%`** 記号で終了します、それであなたはそれを簡単に認識できます。
ドル記号はプロンプトの短い表現としてしばしば使用されます。

## コマンドの入力

プロンプトが表示されたので、コマンドを実行しましょう。
次のように入力し、<kbd>Enter</kbd> を押します：

```sh
echo Hello, terminal!
```

ターミナルは空白に基づいてコマンドを単語に分割します。
上記のコマンドには3つの単語があります：
- `echo`
- `Hello,`
- `terminal!`

最初の単語は実行するプログラムです。
ターミナルはあなたのコンピュータで `echo` というプログラムを見つけ、それを実行します。
プログラムは引数 `Hello,` と `terminal!` を自由に解釈できます。
`echo` というプログラムは引数をターミナルに戻すだけです：

```console
$ echo Hello, terminal!
Hello, terminal!
```

## 現在のワーキングディレクトリ

ターミナルの最も根本的な概念の一つは**現在のワーキングディレクトリ**です。
それはファイルシステム内の場所で、あなたが現在 "いる" 場所です。

ほとんどのコマンドはCWDに基づいて異なる動作をします。
それを変更できる必要があるためです。
それを変更するコマンドは `cd` と呼ばれ、"change directory" の略です。
あなたはおそらく "Downloads" というフォルダを持っていますが、この例では別のものを代用できます：

```console
[username@hostname ~]$ cd Downloads
[username@hostname Downloads]$
```

おお！
**プロンプトが変わった**ことに気づきましたか？
現在のワーキングディレクトリ、またはCWDは重要なので、プロンプトのどこかに表示されることが多いです。
それにより、あなたは常に "どこにいるか" を知ることができます。

`cd` の前の例では、CWDはチルダ **`~`** 文字だったようです。
それはあなたのユーザーの**ホームディレクトリ**の省略形です。
Linuxでは `/home/username` です。
別の方法でCWDを決定するには、`pwd` コマンドを実行します、"print working directory" の略。
それはチルダ **`~`** 文字を完全なパスに展開します。

```
[username@hostname Downloads]$ pwd
/home/username/Downloads
[username@hostname Downloads]$
```

CWDを意識するコマンドの例は `ls` で、ファイルとディレクトリをリストします。
`Downloads` フォルダでそれを実行してください。
おそらくクリーンアップする時が来ました...？

重要な教訓は：
**現在のワーキングディレクトリを意識してください**。
コマンドが期待した動作をしない場合、間違った場所にいる可能性があります。


## コマンドのコピーと貼り付け

このチュートリアルにはコピーして貼り付けるコマンドを含むコードブロックがたくさんあります。
複数のコマンドが別々の行にある場合でも、一度にすべてコピーして貼り付けできます。
コードブロックの上にマウスをホバーすると、隠されたコピーボタンが表示されます。
非常に便利です！

歴史的な理由で、ターミナルでは <kbd>Ctrl</kbd>+<kbd>C</kbd> と <kbd>Ctrl</kbd>+<kbd>V</kbd> はコピーと貼り付けを行いません。
代わりに、<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>C</kbd>/<kbd>V</kbd> をそれぞれ使用します。
Macを使用している場合、<kbd>Command</kbd>+<kbd>C</kbd>/<kbd>V</kbd> が通常動作します。

この間違いを犯してターミナルに <kbd>Ctrl</kbd>+<kbd>V</kbd> を入力しようとした場合（<kbd>Shift</kbd> なし）、それは少し混乱します。
あなたはそれを再試行するために <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd> を使用できますが、そうすると次のようになります：

```console
$ ^[[200~echo Hello, terminal!~
```

これらの奇妙な文字は <kbd>Ctrl</kbd>+<kbd>V</kbd> を <kbd>Shift</kbd> なしで入力した結果の "escape sequence" です。
このコマンドは動作しません。
<kbd>Shift</kbd> を忘れた間違いを犯した場合、<kbd>Enter</kbd> を数回押して新しいプロンプトを取得し、その後再試行してください。

一部のコマンドには `echo` のようなプログラムの後にコメントが含まれます、これらは **`#`** 文字で始まる行です。
ターミナルはそれらを単に無視します。
それらは人間の読者にとってコマンドをより理解しやすくするために使用されますが、コマンド実行には影響しません。

練習するために、次のコマンドをターミナルにコピーして貼り付けてください：

```sh
# いくつかの例のコメント：
#
# これは実行されるプログラムです。
# |
# |  これは最初の引数の開始です。
# |  |
# |  |      これは2番目の引数の開始です。
# v  v      v
echo Hello, terminal! # コマンドの後にコメントを置くこともできます。
```

## リダイレクト

`echo` コマンドが引数をターミナルに戻す方法を見てきました。
しかし、それはデフォルトです。
`echo` は "standard out" または "stdout" と呼ばれるものに印刷するだけです。
それは通常ターミナルに接続されています。
しかし、プログラムのstdoutを**リダイレクト**することができます、例えば `>` 演算子でファイルに：

```sh
echo "bread, onions, tee" > groceries.txt
```

この本では、ファイルを操作するコマンドがこのようなものに見える場合があります。

`>` 演算子はファイルを_上書き_しますが、`>>` 演算子はファイルの末尾に_追加_します。

## ページャー

一部のコマンドはターミナルに大量のテキストを印刷します。
すべてをスクロールして戻るのは面倒です。
ここで**ページャー**が役立ちます。
それは別のプログラムの出力を取り、最初からあなたに表示します。

一部のプログラムは大量のテキストを印刷することを知っているので、自動的に出力にページャーを使用します。
Jujutsuも時々それを行います。
ページャーに "偶然" 入った場合、ボトムレフトにコロン `:` 文字があり、プロンプトが表示されません。
ページャーを使用する実験をする一つの方法は、`man tar` を実行することです、これは `tar` コマンドのマニュアルページを開きます。

さまざまなキー結合でページャーをナビゲートできます。
矢印キー、"page up" と "page down" は期待通り動作します。
もう一つの非常に便利なものは、<kbd>/</kbd> を入力して検索語を入力し、<kbd>Enter</kbd> で検索を開始することです。
検索ヒットをステップするには (lowercase) <kbd>n</kbd> を使用し、後方にステップするには (uppercase) <kbd>N</kbd> を使用します。

## 変数と環境

プログラムをコンピュータで名前で実行することは表面をなぞるだけです。
ターミナルには小さなプログラミング/スクリプト言語が組み込まれています。
例えば、`=` 記号で変数に値を格納し、`$` 記号で評価できます：

```console
$ my_name=Alice
$ echo Hello, $my_name!
Hello, Alice!
```

上記の通常の変数は現在のターミナルセッションでのみ使用できます。
プログラムが読み取ることができるように変数を**環境**にエクスポートする必要があります。
これはプログラムに何を望むかを伝える別の方法です。
より一般的な方法はコマンドラインの引数ですが、エクスポートされた変数は一部の状況で便利です。

変数を設定するのと同時にエクスポートすることも、別々にすることもできます：

```sh
MY_NAME=Alice
export MY_NAME
```

```sh
export MY_NAME=Alice
```

そのようなエクスポートされた変数は通常**環境変数**と呼ばれます。
大文字にする必要はありませんが、それは強い慣習です。
プログラムが読み取ることができる変数を簡単に知ることができます。

## `PATH` 変数

環境変数のうち、最初は混乱しやすいかもしれないものが `PATH` 変数です。
まず、それに何が含まれているか印刷しましょう：

```console
$ echo $PATH
/home/username/.local/bin:/usr/local/bin:/usr/bin
```

あなたの出力は異なるかもしれませんが、構造は同じです：
それはコロン **`:`** 文字で区切られたファイルシステムパスのリストです。
この場合、3つのパスがあります：
- `/home/username/.local/bin`
- `/usr/local/bin`
- `/usr/bin`

これらの3つのパスは何を意味するのでしょうか？
それらはターミナルがプログラムを実行するために検索する場所です！
それを混乱させてみましょう。
`PATH` 変数を空の文字列に設定します：

```sh
export PATH=""
```

今、`ls` のようなプログラムを実行してみてください：

```console
$ ls
bash: ls: No such file or directory
```

`PATH` 変数を空の文字列に設定することは、ターミナルに_どこにも_プログラムを検索しないように指示することです。
したがって、`ls` プログラムが見つかりません。

私たちは以前の値をコピーして貼り付け、`PATH` を再度エクスポートすることで修正できます。
しかし、環境変数の値を誤って変更した場合、以前の正しい値を知らないことが多いです。
したがって、ターミナルウィンドウを閉じて新しいものを開くのが最も簡単です。
すべての変数がデフォルトにリセットされます。

`PATH` 変数が混乱しやすいので、それを決して触らないべきでしょうか？
いいえ。
時々、デフォルトの場所ではなくカスタムの場所にプログラムをインストールしたい（または必要）です。
その場合、`PATH` 変数に保存されたパスのリストを_拡張_する必要があります。
例は次のようになります：

```sh
export PATH="/home/username/my-local-programs:$PATH"
```

これはリストの前に新しいパスを追加し、コロン **`:`** 区切り、そして `$PATH` の以前の値であるリストの残りを追加します。

## スタートアップスクリプト

上記のコマンドで `PATH` 変数を編集することは、現在のターミナルセッションにのみ影響します。
ターミナルを閉じて再開すると、`PATH` の値はデフォルトにリセットされます。
しかし、それが望ましくない場合があります。
カスタムの場所にプログラムをインストールした場合、将来のすべてのターミナルセッションでそれらを自動的に見つけたいかもしれません。

そこでスタートアップスクリプトが登場します。
それらはコマンドのリストを含むファイル（**スクリプト**とも呼ばれる）です。
_スタートアップ_スクリプトは新しいターミナルを開くたびに自動的に実行され、あなたが最初のコマンドを入力する前に。
将来のすべてのターミナルセッションに恒久的な変更を行うための完璧な場所です！

スタートアップスクリプトの場所と名前は**シェル**によって異なります、あなたの特定の "flavor" のターミナル。
ターミナルはかなり標準化されていますので、異なるシェルをあまり心配する必要はありません。
これは例外です。
Linuxを使用している場合、あなたのシェルはおそらく `bash` と呼ばれます。
Macを使用している場合、あなたのシェルはおそらく `zsh` と呼ばれます。
確かめるには、`SHELL` 環境変数を読み取ります：

```console
$ echo $SHELL
/bin/bash
```

シェルが `bash` の場合、スタートアップスクリプトを **`~/.bashrc`** ファイルに追加します。
`zsh` の場合、スタートアップスクリプトは **`~/.zshrc`** です。

今、あなたのスタートアップスクリプトの内容を印刷します。
それは複雑に見えるかもしれませんので、すべて理解しようとしないでください。
それでも、見ることはターミナルに慣れる素晴らしい方法です：

```sh
# bash の場合
cat ~/.bashrc
```

```sh
# zsh の場合
cat ~/.zshrc
```

```admonish tip title="今、ターミナルの基礎を知っています！🎉"
これらのことがすべて新しかった場合、自分を褒めてください！
あなたはすでにたくさんのことを学びました。
このチュートリアルを進めるのに十分なターミナルの知識を持っているはずです。

時々戻って復習してください。
ターミナルのルールは最も直感的ではないので、定着するのに数回の試行が必要かもしれません。
```
